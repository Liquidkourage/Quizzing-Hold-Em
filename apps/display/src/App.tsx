import { useEffect, useState, useCallback, useRef } from 'react'
import { motion, AnimatePresence } from 'framer-motion'
import { NumericPlayingCard, PokerChip } from '@qhe/ui'
import { connect, onState, onToast, onDealingCards, onDealingCommunityCards } from '@qhe/net'
import type { GameState } from '@qhe/core'

function DisplayApp() {
  const [gameState, setGameState] = useState<GameState | null>(null)
  const [toastMessage, setToastMessage] = useState<string | null>(null)
  const [isDealing, setIsDealing] = useState(false)
  
  // Use ref to store the latest animation function to avoid dependency cycles
  const triggerCommunityDealingAnimationRef = useRef<(() => void) | null>(null)
  const [dealingCards, setDealingCards] = useState<Array<{id: string, playerIndex: number, cardIndex: number, digit: number}>>([])
  const [hasDealtCards, setHasDealtCards] = useState(false) // Track if cards have been dealt - start false to hide initial cards
  
  // Community card dealing animation state
  const [isDealingCommunity, setIsDealingCommunity] = useState(false)
  const [dealingCommunityCards, setDealingCommunityCards] = useState<Array<{id: string, cardIndex: number, digit: number, isRevealed: boolean}>>([])
  const [hasDealtCommunityCards, setHasDealtCommunityCards] = useState(false) // Start false - cards only show after dealing animation
  const [showDeck, setShowDeck] = useState(false) // Control deck visibility during animation
  
  // Shared community cards state - used by both animation and static display
  const [sharedCommunityCards, setSharedCommunityCards] = useState<Array<{digit: 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9}>>([])

  useEffect(() => {
    const cleanup = connect('display', 'DISPLAY01')
    return cleanup
  }, [])

  useEffect(() => {
    const unsubscribe = onState((newGameState) => {
      // Clear client-side community card state when server has no cards (new round, etc.)
      if (!newGameState?.round?.communityCards || newGameState.round.communityCards.length === 0) {
        setSharedCommunityCards([])
        setHasDealtCommunityCards(false)
        setDealingCommunityCards([])
        setIsDealingCommunity(false)
      }
      
      setGameState(newGameState)
    })
    return unsubscribe
  }, [])

  useEffect(() => {
    const unsubscribe = onToast((message) => {
      setToastMessage(message)
      setTimeout(() => setToastMessage(null), 3000)
    })
    return unsubscribe
  }, [])

  // Create demo game state with 8 players for demonstration
  const [demoGameState, setDemoGameState] = useState<GameState>({
    code: 'ABC123',
    hostId: 'demo',
    createdAt: Date.now(),
    phase: 'betting',
    bigBlind: 20,
    smallBlind: 10,
    minPlayers: 2,
    maxPlayers: 8,
    players: [
      { id: '1', name: 'Alice', bankroll: 1200, hand: [], hasFolded: false, isAllIn: false },
      { id: '2', name: 'Bob', bankroll: 850, hand: [], hasFolded: false, isAllIn: false },
      { id: '3', name: 'Carol', bankroll: 1100, hand: [], hasFolded: false, isAllIn: false },
      { id: '4', name: 'Dave', bankroll: 950, hand: [], hasFolded: false, isAllIn: false },
      { id: '5', name: 'Eve', bankroll: 1350, hand: [], hasFolded: false, isAllIn: false },
      { id: '6', name: 'Frank', bankroll: 700, hand: [], hasFolded: false, isAllIn: false },
      { id: '7', name: 'Grace', bankroll: 1600, hand: [], hasFolded: false, isAllIn: false },
      { id: '8', name: 'Henry', bankroll: 900, hand: [], hasFolded: false, isAllIn: false },
    ],
    round: {
      roundId: 'demo1',
      pot: 2450,
      communityCards: [], // No demo cards - will be generated by server
      question: {
        id: 'q1',
        text: "What is the capital of France?",
        answer: 1
      },
      dealerIndex: 0
    }
  })

  // Use real game state or demo state
  const displayGameState = gameState || demoGameState

  // Function to trigger dealing animation
  const triggerDealingAnimation = useCallback(() => {
    setIsDealing(true)
    setDealingCards([])
    setHasDealtCards(false) // Hide static cards during animation
    setShowDeck(true) // Show deck for initial deal animation
    
    // Create dealing cards in standard poker order: one card at a time around the table
    const cards: Array<{id: string, playerIndex: number, cardIndex: number, digit: number}> = []
    
    // Deal cards one at a time: first card to all players, then second card to all players
    for (let cardIndex = 0; cardIndex < 2; cardIndex++) {
      displayGameState.players.forEach((player, playerIndex) => {
        if (player.hand.length > cardIndex) {
          // Use actual cards from player's hand
          cards.push({
            id: `dealing-${playerIndex}-${cardIndex}`,
            playerIndex,
            cardIndex,
            digit: player.hand[cardIndex].digit
          })
        } else {
          // Create demo cards for animation if no cards exist yet
          cards.push({
            id: `dealing-${playerIndex}-${cardIndex}`,
            playerIndex,
            cardIndex,
            digit: Math.floor(Math.random() * 9) + 1 // Random digit 1-9
          })
        }
      })
    }
    
    // Animate cards one by one with delays
    cards.forEach((card, index) => {
      setTimeout(() => {
        setDealingCards(prev => [...prev, card])
      }, index * 200) // 200ms delay between each card
    })
    
    // End dealing animation after all cards are dealt
    setTimeout(() => {
      setIsDealing(false)
      setDealingCards([])
      setShowDeck(false) // Hide deck after initial deal
      setHasDealtCards(true) // Mark that cards have been dealt
      
      // For demo mode, populate the player hands with the dealt cards
      if (!gameState) {
        // This is demo mode, so we need to update the demo state with the dealt cards
        const updatedPlayers = displayGameState.players.map((player) => ({
          ...player,
          hand: [
            { digit: (Math.floor(Math.random() * 9) + 1) as 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 },
            { digit: (Math.floor(Math.random() * 9) + 1) as 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 }
          ]
        }))
        
        setDemoGameState(prev => ({
          ...prev,
          players: updatedPlayers
        }))
        

      }
    }, cards.length * 200 + 1000)
  }, [displayGameState.players])

  // Function to trigger community card dealing animation
  const triggerCommunityDealingAnimation = useCallback(() => {
    // Get the current fresh state - use displayGameState to avoid stale closure issues
    const currentGameState = displayGameState || demoGameState
    
    // ONLY use server community cards - NO RANDOM FALLBACK
    if (currentGameState.round.communityCards.length === 0) {
      return // Don't run animation if no server cards
    }
    
    // Use server community cards
    const cardsToUse = currentGameState.round.communityCards.map(card => ({ digit: card.digit }))
    
    // IMMEDIATELY set the shared community cards so static display uses the same values
    setSharedCommunityCards(cardsToUse)
    
    // Start animation immediately with these cards (dealing state already set by event listener)
    setDealingCommunityCards([])
    setShowDeck(true) // Show deck for community cards animation
    
    // Create dealing cards using the cards to use
    const cards: Array<{id: string, cardIndex: number, digit: number, isRevealed: boolean}> = []
    
    cardsToUse.forEach((card, index) => {
      cards.push({
        id: `community-dealing-${index}`,
        cardIndex: index,
        digit: card.digit,
        isRevealed: false // Start face down
      })
    })
    
    // Phase 1: Deal cards face down
    cards.forEach((card, index) => {
      setTimeout(() => {
        setDealingCommunityCards(prev => [...prev, card])
      }, index * 200) // 200ms delay between each card
    })
    
    // Phase 2: Reveal all cards after dealing
    setTimeout(() => {
      setDealingCommunityCards(prev => prev.map(card => ({ ...card, isRevealed: true })))
    }, cards.length * 200 + 500) // Wait for all cards to be dealt + 500ms
    
    // Phase 3: End animation and update server state with these cards
    setTimeout(() => {
      setIsDealingCommunity(false)
      setDealingCommunityCards([])
      setShowDeck(false) // Hide deck after community cards deal
      setHasDealtCommunityCards(true) // Mark that community cards have been dealt
      
      // No need to update demo state - we're using shared community cards state
    }, cards.length * 200 + 500 + 1000) // Wait for dealing + reveal + 1s
  }, [displayGameState]) // Include displayGameState to get fresh state
  
  // Store the latest function in the ref
  useEffect(() => {
    triggerCommunityDealingAnimationRef.current = triggerCommunityDealingAnimation
  }, [triggerCommunityDealingAnimation])

  useEffect(() => {
    const unsubscribe = onDealingCards(() => {
      // Add a delay to wait for the server to update the game state with the new cards
      setTimeout(() => {
        triggerDealingAnimation()
      }, 500) // Wait 500ms for server state update
    })
    return unsubscribe
  }, [displayGameState, triggerDealingAnimation])

  useEffect(() => {
    const unsubscribe = onDealingCommunityCards(() => {
      // IMMEDIATELY set dealing state to prevent static cards from showing
      setIsDealingCommunity(true)
      setHasDealtCommunityCards(false) // Hide static cards during animation
      
      // Wait for the state update to arrive, then trigger animation
      setTimeout(() => {
        // Use the ref to get the latest function
        if (triggerCommunityDealingAnimationRef.current) {
          triggerCommunityDealingAnimationRef.current()
        }
      }, 200) // Wait 200ms for state update to arrive
    })
    return unsubscribe
  }, []) // No dependencies - use ref to avoid cycles

  // Reset hasDealtCards when the round changes to prevent flickering
  useEffect(() => {
    if (gameState && gameState.round) {
      setHasDealtCards(false)
      setHasDealtCommunityCards(false) // Also reset community cards for new rounds
      setSharedCommunityCards([]) // Clear shared community cards for new rounds
      setDealingCommunityCards([]) // Clear any ongoing community card animations
      setIsDealingCommunity(false) // Stop any ongoing community card dealing
    }
  }, [gameState?.round?.roundId])

  if (!displayGameState) {
    return (
      <div className="min-h-screen bg-casino-gradient flex items-center justify-center">
        <div className="text-center">
          <motion.h1 
            className="text-6xl font-black text-casino-emerald mb-8"
            initial={{ opacity: 0, y: -50 }}
            animate={{ opacity: 1, y: 0 }}
            transition={{ duration: 0.8 }}
          >
            🎰 QUIZZING HOLD-EM
          </motion.h1>
          <motion.div 
            className="text-2xl text-white"
            initial={{ opacity: 0 }}
            animate={{ opacity: 1 }}
            transition={{ delay: 0.5, duration: 0.8 }}
          >
            Connecting to server...
          </motion.div>
        </div>
      </div>
    )
  }

  // Calculate player positions around the table (perfectly aligned with cupholders)
  const getPlayerPosition = (index: number, total: number) => {
    const angle = (index / total) * 2 * Math.PI - Math.PI / 2 // Start from top
    
    // Use the same angle logic as cupholders for perfect alignment
    const normalizedAngle = ((angle + Math.PI/2) % (2 * Math.PI)) / (2 * Math.PI)
    
    // Identify top and bottom regions for straight line alignment (same as cupholders)
    const isTopRegion = normalizedAngle > 0.9 || normalizedAngle < 0.1
    const isBottomRegion = normalizedAngle > 0.4 && normalizedAngle < 0.6
    
    // Identify corner regions
    const isCorner = (normalizedAngle > 0.125 && normalizedAngle < 0.375) || 
                     (normalizedAngle > 0.625 && normalizedAngle < 0.875)
    
    let cupholderX, cupholderY
    
    // Calculate cupholder position (scaled up by 1.62x for larger table)
    const scaleTable = 1.62
    if (isTopRegion) {
      const bowAmount = Math.abs(Math.cos(angle)) * (15 * scaleTable)
      cupholderX = Math.cos(angle) * (242 * scaleTable)
      cupholderY = (-180 + bowAmount) * scaleTable
    } else if (isBottomRegion) {
      const bowAmount = Math.abs(Math.cos(angle)) * (15 * scaleTable)
      cupholderX = Math.cos(angle) * (242 * scaleTable)
      cupholderY = (180 - bowAmount) * scaleTable
    } else if (isCorner) {
      cupholderX = Math.cos(angle) * ((242 + 0.5) * scaleTable)
      cupholderY = Math.sin(angle) * ((195 + 0.5) * scaleTable)
    } else {
      cupholderX = Math.cos(angle) * (242 * scaleTable)
      cupholderY = Math.sin(angle) * (195 * scaleTable)
    }
    
    // Calculate direction from table center (0,0) to cupholder
    const cupholderDistance = Math.sqrt(cupholderX * cupholderX + cupholderY * cupholderY)
    const directionX = cupholderX / cupholderDistance
    const directionY = cupholderY / cupholderDistance
    
    // Position player just outside the table by extending the cupholder position outward
    // Adjust extension distance based on position - corners out, edges in
    let extensionDistance = 142 // Base extension (88px * 1.62 scale)
    
    // Determine if this is a corner or edge position for 8-player layout
    // Corner positions: 2,4,6,8 (0-indexed: 1,3,5,7) - need to be pushed out 10%
    // Edge positions: 1,3,5,7 (0-indexed: 0,2,4,6) - need to be pulled in 10%
    const isCornerPosition = index % 2 === 1 // Odd indices are corners (1,3,5,7)
    
    if (isCornerPosition) {
      // Corner positions - push out 10%
      extensionDistance = extensionDistance * 1.1
    } else {
      // Edge positions - pull in 10%
      extensionDistance = extensionDistance * 0.9
    }
    
    const playerX = cupholderX + (directionX * extensionDistance)
    const playerY = cupholderY + (directionY * extensionDistance)
    
    // Position relative to the table center
    // Table is centered at 50% with transform translate
    // Adjust for offset to align with visual center
    return { x: `calc(50% + ${playerX}px - 55px)`, y: `calc(50% + ${playerY}px - 60px)` }
  }

  return (
    <div className="min-h-screen bg-gradient-to-br from-slate-900 via-slate-800 to-slate-900 relative overflow-hidden">
      {/* Casino Floor Background */}
      <div className="absolute inset-0">
        {/* Base casino floor */}
        <div className="absolute inset-0 bg-gradient-to-br from-slate-900 via-slate-800 to-slate-900"></div>
        
        {/* Much more visible carpet pattern overlay */}
        <div className="absolute inset-0 opacity-60">
          <div className="w-full h-full" style={{
            backgroundImage: `
              radial-gradient(circle at 25% 25%, rgba(139, 69, 19, 0.3) 3px, transparent 3px),
              radial-gradient(circle at 75% 75%, rgba(160, 82, 45, 0.3) 3px, transparent 3px),
              linear-gradient(45deg, transparent 48%, rgba(139, 69, 19, 0.15) 49%, rgba(139, 69, 19, 0.15) 51%, transparent 52%),
              linear-gradient(-45deg, transparent 48%, rgba(160, 82, 45, 0.15) 49%, rgba(160, 82, 45, 0.15) 51%, transparent 52%)
            `,
            backgroundSize: '40px 40px, 40px 40px, 80px 80px, 80px 80px',
            backgroundPosition: '0 0, 20px 20px, 0 0, 0 0'
          }}></div>
        </div>
        
        {/* Ambient lighting effects */}
        <div className="absolute inset-0 bg-gradient-to-tr from-amber-500/5 via-transparent to-blue-500/5"></div>
        <div className="absolute inset-0 bg-gradient-to-bl from-red-500/3 via-transparent to-green-500/3"></div>
        
        {/* Overhead lighting spots */}
        <div className="absolute top-0 left-1/4 w-96 h-96 bg-gradient-radial from-yellow-200/10 to-transparent rounded-full"></div>
        <div className="absolute top-0 right-1/4 w-96 h-96 bg-gradient-radial from-yellow-200/10 to-transparent rounded-full"></div>
        <div className="absolute bottom-0 left-1/3 w-80 h-80 bg-gradient-radial from-blue-200/8 to-transparent rounded-full"></div>
        
        {/* Wall texture */}
        <div className="absolute inset-0 opacity-20">
          <div className="w-full h-full" style={{
            backgroundImage: `
              linear-gradient(90deg, transparent 98%, rgba(255, 255, 255, 0.1) 100%),
              linear-gradient(0deg, transparent 98%, rgba(255, 255, 255, 0.1) 100%)
            `,
            backgroundSize: '20px 20px'
          }}></div>
        </div>
      </div>

      {/* Toast Messages */}
      <AnimatePresence>
        {toastMessage && (
          <motion.div
            className="fixed top-4 right-4 z-50 bg-black/80 backdrop-blur-md border border-white/20 rounded-xl shadow-lg p-4 text-white"
            initial={{ opacity: 0, x: 100 }}
            animate={{ opacity: 1, x: 0 }}
            exit={{ opacity: 0, x: 100 }}
            transition={{ duration: 0.3 }}
          >
            {toastMessage}
          </motion.div>
        )}
      </AnimatePresence>



      <div className="relative z-10 p-2">
        {/* Header */}
        <motion.div 
          className="text-center mb-2"
          initial={{ opacity: 0, y: -50 }}
          animate={{ opacity: 1, y: 0 }}
          transition={{ duration: 0.8 }}
        >
          <h1 className="text-4xl font-black text-yellow-400 mb-2 flex items-center justify-center gap-2">
            🎰 ALL <PokerChip size="lg" className="mx-1" /> INQUIZITION
          </h1>
          <div className="text-lg text-white">
            Room: <span className="text-yellow-400 font-bold">{displayGameState.code}</span> | 
            Phase: <span className="text-yellow-400 font-bold">{displayGameState.phase}</span>
            {!gameState && <span className="text-red-400 ml-2">(DEMO MODE - 8 Players)</span>}
          </div>
          

        </motion.div>

        {/* Main Game Area */}
        <div className="relative w-full h-screen max-w-7xl mx-auto">
          

          
          {/* Dealing Animation */}
          <AnimatePresence>
            {isDealing && (
              <div className="absolute inset-0 z-50 pointer-events-none">
                
                {/* Dealer deck of cards - positioned below the tableau */}
                <motion.div
                  className="absolute"
                  style={{
                    left: 'calc(50% - 50px)', // Move deck more to the right
                    top: 'calc(50% + 100px)', // Move deck down below the tableau
                    transform: 'translate(-50%, -50%)'
                  }}
                  initial={{ scale: 0, opacity: 0, rotateY: 0 }}
                  animate={{ scale: 1, opacity: 1, rotateY: 0 }}
                  exit={{ scale: 0, opacity: 0 }}
                  transition={{ duration: 0.5 }}
                >
                  {/* Stack of cards to simulate a deck */}
                  {[...Array(5)].map((_, i) => (
                    <motion.div
                      key={i}
                      className="absolute"
                      style={{
                        left: `${i * 2}px`,
                        top: `${i * -1}px`,
                        zIndex: 5 - i
                      }}
                      animate={{
                        rotateY: [0, 5, -5, 0],
                        scale: [1, 1.05, 1]
                      }}
                      transition={{
                        duration: 2,
                        repeat: Infinity,
                        delay: i * 0.1
                      }}
                    >
                      <NumericPlayingCard 
                        digit={0} 
                        variant="cyan" 
                        size="small" 
                        faceDown={true}
                        backDesign="star"
                        style="neon"
                        neonVariant="matrix"
                      />
                    </motion.div>
                  ))}
                </motion.div>
                {dealingCards.map((dealingCard) => {
                  // Calculate exact endpoint to match static card positioning
                  const calculateCardEndpoint = (playerIndex: number, cardIndex: number) => {
                    const playerPosition = getPlayerPosition(playerIndex, displayGameState.players.length)
                    
                    // Parse the position values
                    const targetX = parseFloat(playerPosition.x.replace('calc(50% + ', '').replace('px)', ''))
                    const targetY = parseFloat(playerPosition.y.replace('calc(50% + ', '').replace('px)', ''))
                    
                    // Calculate center relative to container
                    const containerWidth = window.innerWidth
                    const viewportHeight = window.innerHeight
                    const centerX = containerWidth / 2
                    const centerY = viewportHeight / 2
                    
                    // Player container positioning: absolute with transform -translate-x-1/2 -translate-y-1/2
                    const playerCenterX = centerX + targetX
                    const playerCenterY = centerY + targetY
                    
                    // Static card positioning inside player container:
                    // - Container: w-[120px] h-[130px] with scale-[1.40625]
                    // - Cards: absolute bottom-0 left-1/2 transform -translate-x-1/2 flex
                    // - Each card: scale-50 origin-bottom with marginLeft: i === 0 ? '0' : '-50px'
                    
                    const containerScale = 1.40625
                    const cardScale = 0.5
                    
                    // Container dimensions after scaling
                    const scaledHeight = 130 * containerScale
                    
                    // Cards are positioned at bottom-0 (bottom of container)
                    const cardsBottomY = playerCenterY + (scaledHeight / 2)
                    
                    // Cards use flex with overlapping via negative margin
                    // First card (index 0): no offset
                    // Second card (index 1): -50px margin (before scale)
                    const baseCardWidth = 96 // Normal NumericPlayingCard width
                    const baseCardHeight = 144 // Normal NumericPlayingCard height
                    const scaledCardWidth = baseCardWidth * cardScale * containerScale
                    const cardOverlap = -50 // px overlap before scaling
                    
                    // Calculate card X position
                    // Cards are centered horizontally (left-1/2 transform -translate-x-1/2)
                    // Add small offset to move cards slightly right and up
                                          const horizontalOffset = 9 // px adjustment to move right (fine-tuned from 12)
                    const verticalOffset = -8 // px adjustment to move up
                    let cardX
                    
                    if (cardIndex === 0) {
                      // First card is centered
                      cardX = playerCenterX - (scaledCardWidth / 2) + horizontalOffset
                    } else {
                      // Second card overlaps by -50px (before container scaling)
                      const overlapScaled = cardOverlap * containerScale
                      cardX = playerCenterX - (scaledCardWidth / 2) + overlapScaled + horizontalOffset
                    }
                    
                    // Card Y position accounts for card height and origin-bottom
                    const scaledCardHeight = baseCardHeight * cardScale * containerScale
                    const cardY = cardsBottomY - scaledCardHeight + verticalOffset
                    
                    return { x: cardX, y: cardY, scale: cardScale * containerScale }
                  }
                  
                  const endpoint = calculateCardEndpoint(dealingCard.playerIndex, dealingCard.cardIndex)
                  
                  // Calculate exact center for animation start (same as deck position)
                  const centerX = (window.innerWidth / 2) - 50 // Match deck position
                  const centerY = window.innerHeight / 2 + 100 // Match deck position
                  
                  const finalX = endpoint.x
                  const finalY = endpoint.y
                  const finalScale = endpoint.scale
                  
                  return (
                    <motion.div
                      key={dealingCard.id}
                      className="absolute"
                      style={{ 
                        left: 0, 
                        top: 0 
                      }}
                      initial={{ 
                        x: centerX,
                        y: centerY,
                        scale: 0.1,
                        rotate: Math.random() * 360 - 180,
                        opacity: 0
                      }}
                      animate={{ 
                        x: finalX,
                        y: finalY,
                        scale: finalScale, // Match the exact card scale
                        rotate: 0,
                        opacity: 1
                      }}
                      transition={{ 
                        duration: 1.2,
                        ease: "easeOut",
                        type: "spring",
                        stiffness: 100,
                        damping: 10
                      }}
                    >
                      <NumericPlayingCard 
                        digit={dealingCard.digit} 
                        variant="cyan" 
                        size="normal" 
                        faceDown={true}
                        backDesign="star"
                        style="neon"
                        neonVariant="pulse"
                      />
                    </motion.div>
                  )
                })}
              </div>
            )}
          </AnimatePresence>

          {/* Community Card Dealing Animation */}
          <AnimatePresence>
            {isDealingCommunity && (
              <div className="absolute inset-0 z-50 pointer-events-none">
                
                {/* Dealer deck of cards - positioned below the tableau */}
                {showDeck && (
                  <motion.div
                    className="absolute"
                    style={{
                      left: 'calc(50% - 50px)', // Move deck more to the right
                      top: 'calc(50% + 100px)', // Move deck down below the tableau
                      transform: 'translate(-50%, -50%)'
                    }}
                    initial={{ scale: 0, opacity: 0, rotateY: 0 }}
                    animate={{ scale: 1, opacity: 1, rotateY: 0 }}
                    exit={{ scale: 0, opacity: 0 }}
                    transition={{ duration: 0.5 }}
                  >
                  {/* Stack of cards to simulate a deck */}
                  {[...Array(5)].map((_, i) => (
                    <motion.div
                      key={i}
                      className="absolute"
                      style={{
                        left: `${i * 2}px`,
                        top: `${i * -1}px`,
                        zIndex: 5 - i
                      }}
                      animate={{
                        rotateY: [0, 5, -5, 0],
                        scale: [1, 1.05, 1]
                      }}
                      transition={{
                        duration: 2,
                        repeat: Infinity,
                        delay: i * 0.1
                      }}
                    >
                      <NumericPlayingCard 
                        digit={0} 
                        variant="cyan" 
                        size="small" 
                        faceDown={true}
                        backDesign="star"
                        style="neon"
                        neonVariant="matrix"
                      />
                    </motion.div>
                  ))}
                </motion.div>
                )}
                {dealingCommunityCards.map((dealingCard) => {
                  // Calculate exact endpoint for community card positioning (relative to table center)
                  const calculateCommunityCardEndpoint = (cardIndex: number) => {
                    // Community cards are positioned at the center of the table
                    const tableCenterX = window.innerWidth / 2
                    const tableCenterY = window.innerHeight / 2
                    
                                      // Calculate position for each community card in a horizontal row
                  const cardWidth = 64 // small card width (64px)
                  const cardSpacing = 8 // gap between cards
                  const totalWidth = (5 * cardWidth) + (4 * cardSpacing) // 5 cards total
                  // Move left so that the 3rd card (index 2) is centered - smaller offset
                  const startX = tableCenterX - (totalWidth / 2) - ((cardWidth + cardSpacing) * 0.75)
                  
                  const cardX = startX + (cardIndex * (cardWidth + cardSpacing)) + (cardWidth / 2)
                    const cardY = tableCenterY - 48 // Move up by same amount as static cards (-translate-y-12 = -48px)
                    
                    return { x: cardX, y: cardY, scale: 1.5 } // larger scale for community cards (more dramatic growth from deck)
                  }
                  
                  const { x: finalX, y: finalY, scale: finalScale } = calculateCommunityCardEndpoint(dealingCard.cardIndex)
                  
                  // Calculate center for animation start (same as deck position)
                  const centerX = (window.innerWidth / 2) - 50 // Match deck position
                  const centerY = window.innerHeight / 2 + 100 // Match deck position
                  
                  return (
                    <motion.div
                      key={dealingCard.id}
                      className="absolute"
                      initial={{ 
                        x: centerX, 
                        y: centerY, 
                        scale: 0.05, // Start even smaller for more dramatic growth
                        rotate: Math.random() * 360 - 180, 
                        opacity: 0 
                      }}
                      animate={{ 
                        x: finalX, 
                        y: finalY, 
                        scale: finalScale, // Scale up to community card size
                        rotate: 0, 
                        opacity: 1 
                      }}
                      transition={{ 
                        duration: 1.2, 
                        ease: "easeOut", 
                        type: "spring", 
                        stiffness: 100, 
                        damping: 10 
                      }}
                    >
                                                  <NumericPlayingCard 
                              digit={dealingCard.digit} 
                              variant="cyan" 
                              size="small" 
                              faceDown={!dealingCard.isRevealed}
                              style="neon"
                              neonVariant="pulse"
                            />
                    </motion.div>
                  )
                })}
            </div>
            )}
          </AnimatePresence>
          {/* Players positioned around the table */}
          {displayGameState.players.map((player, index) => {
            const position = getPlayerPosition(index, displayGameState.players.length)
            return (
              <motion.div 
                key={player.id} 
                className="absolute transform -translate-x-1/2 -translate-y-1/2 z-20"
                style={{ 
                  left: position.x, 
                  top: position.y 
                }}
                initial={{ opacity: 0, scale: 0 }}
                animate={{ opacity: 1, scale: 1 }}
                transition={{ delay: index * 0.1, duration: 0.5 }}
              >
                <div className="bg-black/90 backdrop-blur-md border-2 border-yellow-600 rounded-lg p-3 text-center w-[120px] h-[130px] shadow-lg transform scale-[1.40625] origin-center relative">
                  <div className="text-yellow-400 font-bold text-sm mb-1">{player.name}</div>
                  <div className="text-white text-sm mb-1">
                    ${player.bankroll}
                  </div>
                  
                  {/* Player's hand - docked at bottom edge with overlapping cards */}
                  {player.hand.length > 0 && !isDealing && hasDealtCards && (
                    <div className="absolute bottom-0 left-1/2 transform -translate-x-1/2 flex">
                      {player.hand.map((card, i) => (
                        <div key={i} className="transform scale-50 origin-bottom" style={{ marginLeft: i === 0 ? '0' : '-50px' }}>
                          <NumericPlayingCard 
                            digit={card.digit} 
                            variant="cyan" 
                            size="normal" 
                            faceDown={displayGameState.phase !== 'showdown' || player.hasFolded} 
                            backDesign="star" 
                          />
                        </div>
                      ))}
                    </div>
                  )}
                  
                  {/* Player status */}
                  {player.hasFolded && (
                    <div className="absolute bottom-6 left-1/2 transform -translate-x-1/2 text-red-400 font-bold text-xs">FOLDED</div>
                  )}
                </div>
              </motion.div>
            )
          })}

          {/* Realistic Poker Table - Centered vertically in available space */}
          <div className="absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 z-10">
            {/* Table shadow */}
            <div className="absolute inset-0 w-[842px] h-[637px] bg-black/40 rounded-full blur-lg transform translate-y-2"></div>
            
            {/* Table base/rail */}
            <div className="w-[810px] h-[605px] bg-gradient-to-br from-amber-800 via-amber-700 to-amber-900 rounded-full border-8 border-amber-600 shadow-2xl relative">
                            {/* FELT SURFACE - Direct application to rail padding */}
              <div 
                className="absolute inset-2 rounded-full border-4 border-amber-500"
                style={{
                  background: `
                    repeating-linear-gradient(
                      45deg,
                      #2d5a3d 0px,
                      #2d5a3d 2px,
                      #1f4429 2px,
                      #1f4429 4px
                    ),
                    repeating-linear-gradient(
                      -45deg,
                      transparent 0px,
                      transparent 2px,
                      rgba(0, 0, 0, 0.15) 2px,
                      rgba(0, 0, 0, 0.15) 4px
                    ),
                    linear-gradient(135deg, #2d7a4a, #1e5a33, #2d7a4a)
                  `,
                  backgroundSize: '4px 4px, 4px 4px, 100% 100%'
                }}
              >
                {/* Table markings - betting lines */}
                <div className="absolute inset-8 border-2 border-white/20 rounded-full"></div>
                <div className="absolute inset-12 border border-white/10 rounded-full"></div>
              </div>
                


              {/* Cup holders centered on the middle rail stripe - one per player */}
              {displayGameState.players.map((_, index) => {
                const angle = (index / displayGameState.players.length) * 2 * Math.PI - Math.PI / 2
                
                // Base ellipse dimensions - scaled up for larger table
                const baseRadiusX = 392  // Horizontal radius (242 * 1.62)
                const baseRadiusY = 316  // Vertical radius (195 * 1.62)
                
                // Calculate base position
                let x = Math.cos(angle) * baseRadiusX
                let y = Math.sin(angle) * baseRadiusY
                
                // Adjust positioning based on angle regions
                const normalizedAngle = ((angle + Math.PI/2) % (2 * Math.PI)) / (2 * Math.PI)
                
                // Identify top and bottom regions for straight line alignment
                const isTopRegion = normalizedAngle > 0.9 || normalizedAngle < 0.1
                const isBottomRegion = normalizedAngle > 0.4 && normalizedAngle < 0.6
                
                // Identify corner regions
                const isCorner = (normalizedAngle > 0.125 && normalizedAngle < 0.375) || 
                               (normalizedAngle > 0.625 && normalizedAngle < 0.875)
                
                if (isTopRegion) {
                  // Create more pronounced inward bow for top line
                  const bowAmount = Math.abs(Math.cos(angle)) * 24.3 // Bow inward (15 * 1.62)
                  y = -291.6 + bowAmount // Positioning (-180 * 1.62)
                } else if (isBottomRegion) {
                  // Create more pronounced inward bow for bottom line
                  const bowAmount = Math.abs(Math.cos(angle)) * 24.3 // Bow inward (15 * 1.62)
                  y = 291.6 - bowAmount // Positioning (180 * 1.62)
                } else if (isCorner) {
                  // Push corners out by increasing radius - minimal boost for nearly flat
                  x = Math.cos(angle) * (baseRadiusX + 0.81)
                  y = Math.sin(angle) * (baseRadiusY + 0.81)
                }
                
                // Note: Individual adjustments removed since we now have 8 cupholders instead of 50
                
                return (
                  <div 
                    key={`cupholder-${index}`}
                    className="absolute bg-amber-800 rounded-full border-2 border-amber-600 transform -translate-x-1/2 -translate-y-1/2 flex items-center justify-center"
                    style={{ 
                      left: `${394 + x}px`, 
                      top: `${293 + y}px`,
                      width: '32px',
                      height: '32px'
                    }}
                                      >
          </div>
                )
              })}
              
              {/* Original cupholders (hidden for now) */}
              {false && displayGameState.players.map((_, index) => {
                const angle = (index / displayGameState.players.length) * 2 * Math.PI - Math.PI / 2
                const railCenterRadiusX = 248
                const railCenterRadiusY = 180
                const x = Math.cos(angle) * railCenterRadiusX
                const y = Math.sin(angle) * railCenterRadiusY
                
                return (
                  <div 
                    key={`original-cupholder-${index}`}
                    className="absolute w-6 h-6 bg-amber-800 rounded-full border-2 border-amber-600 transform -translate-x-1/2 -translate-y-1/2"
                    style={{ 
                      left: `${243 + x}px`, 
                      top: `${181 + y}px` 
                    }}
                  ></div>
                )
              })}
              
              {/* Pot display - positioned higher */}
              <div className="absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-36 text-center">
                <div className="bg-black/60 backdrop-blur-sm border border-white/20 rounded-lg px-4 py-2">
                  <div className="text-white text-sm">Pot: <span className="text-yellow-400 font-bold text-2xl">${displayGameState.round.pot}</span></div>
                </div>
              </div>

              {/* Community Cards - positioned inside table at center */}
              <div className="absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 -translate-y-12">
                {/* Show community cards if they exist in server state OR if animation has completed */}
                {(() => {
                  const shouldShowServerCards = displayGameState.round.communityCards.length > 0 && !isDealingCommunity
                  const shouldShowAnimationCards = sharedCommunityCards && sharedCommunityCards.length > 0 && hasDealtCommunityCards
                  const cardsToShow = displayGameState.round.communityCards.length > 0 ? displayGameState.round.communityCards : sharedCommunityCards
                  
                  return (shouldShowServerCards || shouldShowAnimationCards) ? (
                    cardsToShow.map((card, i) => {
                      // Use relative positioning within the table
                      const cardWidth = 64 // small card width (64px)
                      const cardSpacing = 8 // gap between cards
                      const totalWidth = (5 * cardWidth) + (4 * cardSpacing) // 5 cards total
                      // Move left so that the 3rd card (index 2) is centered - smaller offset
                      const startX = -(totalWidth / 2) - ((cardWidth + cardSpacing) * 0.75) // Start from center and go left by half total width plus smaller offset for 3rd card
                      
                      const cardX = startX + (i * (cardWidth + cardSpacing)) + (cardWidth / 2)
                      const cardY = 0 // Center vertically
                    
                      return (
                        <div
                          key={i}
                          className="absolute"
                          style={{
                            left: cardX - (64 * 1.5 / 2) + 42, // Offset by half the scaled card width + even larger right offset (1 pixel more)
                            top: cardY - (96 * 1.5 / 2) + 43, // Offset by half the scaled card height + smaller down offset (1 pixel more)
                            transform: 'scale(1.5)', // Scale to match animation
                            transformOrigin: '0 0' // Scale from top-left corner
                          }}
                        >
                          <NumericPlayingCard 
                            digit={card.digit} 
                            variant="cyan" 
                            style="neon" 
                            neonVariant="matrix" 
                            size="small" 
                          />
                        </div>
                      )
                    })
                  ) : (
                    <div className="text-white/60 text-sm bg-black/40 backdrop-blur-sm rounded px-2 py-1">
                      No community cards
                    </div>
                  )
                })()}
              </div>

              {/* Current question - positioned above pot */}
              {displayGameState.round.question && (
                <div className="absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-36 w-72">
                  <div className="bg-black/80 backdrop-blur-md border border-white/20 rounded-lg p-3 text-center">
                    <div className="text-white text-sm mb-1">Current Question:</div>
                    <div className="text-yellow-400 font-bold text-sm">{displayGameState.round.question.text}</div>
                  </div>
                </div>
              )}
            </div>
          </div>
        </div>

      </div>

      {/* Game Info Panel - Docked to bottom of screen */}
      <div className="fixed bottom-0 left-0 right-0 z-30 p-4">
        <div className="max-w-4xl mx-auto">
          <div className="bg-black/90 backdrop-blur-md border border-yellow-600 rounded-lg p-4">
            <div className="grid grid-cols-2 md:grid-cols-4 gap-4 text-center">
            <div>
                <div className="text-white text-sm">Players</div>
                <div className="text-yellow-400 font-bold text-xl">{displayGameState.players.length}</div>
            </div>
            <div>
                <div className="text-white text-sm">Total Pot</div>
                <div className="text-yellow-400 font-bold text-xl">${displayGameState.round.pot}</div>
            </div>
            <div>
                <div className="text-white text-sm">Phase</div>
                <div className="text-yellow-400 font-bold text-xl">{displayGameState.phase}</div>
            </div>
            <div>
                <div className="text-white text-sm">Room Code</div>
                <div className="text-yellow-400 font-bold text-xl">{displayGameState.code}</div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  )
}

export default DisplayApp
